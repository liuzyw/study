{
  "title": "Git",
  "cells": [
    {
      "type": "markdown",
      "data": "# <font color=#8DEEEE face=\"黑体\">Git基础</font>\n\n一、在Git中，大部分命令都是在本地完成的，只和本地的文件或资源打交道，不需要连接到远程服务器和别的机器。在Git中的文件有三种状态：已提交（commited）、已修改（modified）和已计划（staged）。\n&nbsp;&nbsp;&nbsp;&nbsp;1 已提交的意思是该文件已经提交到本地库，注意是本地库。\n&nbsp;&nbsp;&nbsp;&nbsp;2 已修改的意思是该文件已经被修改，但是还没有计划提交\n&nbsp;&nbsp;&nbsp;&nbsp;3   已计划它要表达的意思是本文件已经修改，而且已经提到下一次提交的日程上来了。\n\n二、这样在本地就可以划分三个区域\n&nbsp;&nbsp;&nbsp;&nbsp;1 工作目录 这里的所有文件是你正在编辑的文件，已修改的\n&nbsp;&nbsp;&nbsp;&nbsp;2 已计划区域 这里的文件是被修改过的，并且安排到下一次提交的文件\n&nbsp;&nbsp;&nbsp;&nbsp;3 Git库 这里的文件是已被提交的文件\n\n\n三、基本的 Git 工作流程如下：\n&nbsp;&nbsp;&nbsp;&nbsp;1 在工作目录中修改某些文件。\n&nbsp;&nbsp;&nbsp;&nbsp;2 对修改后的文件进行快照，然后保存到暂存区域。\n&nbsp;&nbsp;&nbsp;&nbsp;3 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录\nGit使用<font color=#9AFF9A face=\"黑体\"> SHA-1 </font>来校验文件或文件夹等是否被修改。实际上在Git的库里，不是使用文件名来存储，而是使用SHA-1哈希来保存。"
    },
    {
      "type": "markdown",
      "data": "`.gitignore` 目录中配置一些不需要更新同步的文件\n"
    },
    {
      "type": "markdown",
      "data": "\n\n# <font color=#8DEEEE face=\"黑体\">Git基本命令</font>\n\n### <font color=#00BFF>1 用户信息</font>\n<code><font color=#7CCD7C>git config --global user.name 'zhangsan' </font></code>\n<code><font color=#7CCD7C>git config --global user.email zhansan@qq.com </font></code>\n如果用了 global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 global 选项重新配置即可，新的设定保存在当前项目的 <font color=#7CCD7C> .git/config</font>文件里。\n\n###  <font color=#00BFF>2 查看配置信息</font>\n<font color=#7CCD7C>`git config --list`</font>\n`user.name=Scott Chacon`\n `user.email= schacon@gmail.com`\n` color.status=auto`\n` color.branch=auto`\n` color.interactive=auto`\n` color.diff=auto`\n`...`\n\n### <font color=#00BFF>3 获取帮助</font>\n\n<code>git help \\<verb\\></code>\n\n### <font color=#00BFF>4 初始化本地库</font>\n`git init`\n这样会在\\<your project dir\\>目录中创建一个名为 `.git`的目录，这里会保存一些重要信息。\n\n已有一个Git库，复制一份\n`git clone git://github.com/yuyijq/async.git \\<your project dir\\>`\n你可以指定或不指定\\<your project dir\\>，不指定的话这里就使用async了。\ngit status 看目前的状态\n\n### <font color=#00BFF>5 Git新增档桉</font>\n`git add .` \\# 将资料先暂存到 staging area, add 之后再新增的资料, 于此次 commit 不会含在里面.\n`git add filename`\n`git add modify-file` \\# 修改过的档桉, 也要 add . (不然 commit 要加上 -a 的参数)\n`git add -u `\\# 只加修改过的档桉, 新增的档桉不加入.\n`git add -i` \\# 进入互动模式\n\n### <font color=#00BFF>6 git diff</font>\n`git diff master` \\# 与 Master 有哪些资料不同\n`git diff --cached` \\# 比较 staging area 跟本来的 Repository\n`git diff tag1 tag2` \\# tag1, 与 tag2 的 diff\n`git diff tag1:file1 tag2:file2` \\# tag1, 与 tag2 的 file1, file2 的 diff\n`git diff` \\# 比较 目前位置 与 staging area\n`git diff HEAD` \\# 查看与最新提交的差别\n`git diff new-branch` \\# 比较目前位置 与 branch(new-branch) 的差别\n`git diff --stat`\n`git difftool` 通过图形化的方式或其 NOTE 它格式输出\n`git difftool --tool-help`命令来看你的系统支持哪些Git Diff 插件\n\n### <font color=#00BFF>7 Git show</font>\n`git show ebff` \\# 查 log 是 commit ebff810c461ad1924fc422fd1d01db23d858773b 的内容\n`git show v1` \\# 查 tag:v1 的修改内容\n`git show v1:test.txt` \\# 查 tag:v1 的 test.txt 档桉修改内容\n`git show HEAD` \\# 此版本修改的资料\n`git show HEAD^` \\# 前一版修改的资料\n`git show HEAD^^` \\# 前前一版修改的资料\n`git show HEAD~4` \\# 前前前前一版修改的资料\n\n### <font color=#00BFF>8 Git reset </font>\n\n`git reset --hard HEAD` \\# 还原到最前面 \n`git reset --hard HEAD~3`\n`git reset --soft HEAD~3`\n`git reset HEAD [file]` 取消已经添加到暂存区里的文件\n`git reset HEAD filename` \\# 从 staging area 状态回到 unstaging 或 untracked (档桉内容并不会改变)\n`git reset –hard [8ff24a6803173208f3e6]` 回滚到之前某一commit\n\n### <font color=#00BFF>9 git commit</font>\n`git commit -m 'commit message'`\n`git commit -am 'commit -message'` \\# 将所有修改过得档桉都 commit, 但是 新增的档桉 还是得要先 add.\n`git commit -a -v` \\# -v 可以看到档桉哪些内容有被更改, -a 把所有修改的档桉都 commit\n`git commit --amend` 修改最后一次提交\n\n<code>git commit -m 'initial commit'\n   git add forgotten_file\n  git commit --amend</code>\n\n//---第2次提交修改了第一次提交\n<code>git commit -m 'initial commit'\ngit add forgotten\\_file\ngit commit --amend</code>\n\n###<font color=#00BFF> 10 移除文件</font>\n`git rm fileName`\n`git rm -f [file]`\n`git rm --cached readme.txt` //移除跟踪但不删除文件\ngit rm 是Git用来从工作区，或者暂存区移除文件的命令\ngit clean是一个用来从工作区中移除不想要的文件的命令\n\n###<font color=#00BFF> 11 移动文件</font>\n`git mv file_from file_to`\n\n### <font color=#00BFF> 12 Git log</font>\n`git log` \\# 将所有 log 秀出\n`git log -p` \\# 将所有 log 和修改过得档桉内容列出\n`git log --stat --summary` \\# 查每个版本间的更动档桉和行数\n`git log -S'foo()'` \\# log 裡面有 foo() 这字串的.\n`git log --no-merges` \\# 格式化的项目提交历史\n`git log --since=\"2 weeks ago\"` \\# 最后这 2周的 log\n`git log --pretty=oneline `\\# 将每个提交放在一行显示，查看的提交数很大时非常有用\n`git log --pretty=format:'%h by %an, %ad, %ar, %cd, commit: %s'`\n`git log --pretty=format:'%h : %s' --graph `\\# 会有简单的文字图形化, 分支等.\n`git log --pretty=format:'%h : %s' --topo-order --graph` \\# 依照主分支排序\n`git log --pretty=format:'%h : %s' --date-order --graph` \\# 依照时间排序\n`git log --pretty=short` 显示第一行简述信息\n`git log [file/dir]` 显示指定目录、文件的日志\n`git log -p [file]` 加上 - p参数，文件的前后差 别就会显示在提交信息之后\n`git log --graph` 以图表形式查看分支\n`git reflog` 查看当前仓库的操作日志\n`git log --stat` 每次提交的简略的统计信息\n`git log --pretty=format:\"%h %s\" --graph`\n`git log --since=2.weeks`  列出所有最近两周内的提交\n`git log --oneline master` 列出master分支提交信息\n\n### <font color=#00BFF> 13 分支和合并 </font>\n`git remote -v`      '列出远程地址'\n\n添加远程仓库\n`git remote add Name git://github.com/paulboone/ticgit.git`\n\n从远程仓库抓取数据\n`git fetch [remote-name]` 拥有那个远程仓库中所有分支的引用，可以随时合并或查看\ngit fetch命令与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后 存储在你本地数据库中。\ngit pull命令基本上就是git fetch和git merge命令的组合体，Git从你指定的远程仓库中抓取内容， 然后马上尝试将其合并进你所在的分支中。\n\n`git pull` 合并远程的全部分支到本地\n\ngit pull与git fetch的区别在于git-pull将版本记录下载下来后，还要与本地分支进行合并。所以相当于 git-pull = git-fetch + git-merge\n\n推送数据到远程仓库\n`git push origin master` \\#推送 origin 到 master\n\n`git push origin --delete [branchName]` 删除远程分支\n查看远程仓库信息\n`git remote show origin`\n\n远程仓库的删除和重命名\n`git remote rename pb paul` \\# pb 改成 paul 分支对应前缀也会发生变化\n\n`git remote rm paul` \\# 貌似删除\n\n###<font color=#00BFF> 14 Git Tag </font>\n`git tag v1 ebff` \\# log 是 commit ebff810c461ad1924fc422fd1d01db23d858773b 的内容, 设定简短好记得 Tag: v1\n`git tag` 中文 ebff \\# tag 也可以下中文, 任何文字都可以\n`git tag -d `中文 \\# 把 tag=中文 删掉\n`git push —tags ` 把本地tag推送到远程\n`git fetch origin tag [tagname]` 获取远程tag\n` git tag` 列显已有的标签\n` git tag -l 'v1.4.2.\\*'`\\#搜索标签\n\n新建标签\n `git tag -a v1.4 -m 'my version 1.4'` \\#新建v1.4标签 消息是 my version 1.4\n\n分享标签\n `git push origin [tagname]` \\#提交 一个标签\n` git push origin --tags` \\# 推送所有本地标签\n `git push origin --delete tag \\<tagname\\>  `删除远程标签\n\n\n###<font color=#00BFF> 15 Git branch</font>\n`git branch` \\# 列出目前有多少 branch\n`git branch new-branch` \\# 产生新的 branch (名称: new-branch), 若没有特别指定, 会由目前所在的 branch  master 直接复制一份.\n`git branch new-branch master `\\# 由 master 产生新的 branch(new-branch)\n`git branch new-branch v1` \\# 由 tag(v1) 产生新的 branch(new-branch)\n`git branch -d new-branch` \\# 删除 new-branch\n`git branch -D new-branch` \\# 强制删除 new-branch\n`git checkout -b new-branch test` \\# 产生新的 branch, 并同时切换过去new-branch\n`git branch recover-branch ab1afef` 切换至某个提交\n\\# 与 remote repository 有关\n`git branch -r `\\# 列出所有 Repository branch\n`git branch -a `\\# 列出所有 branch\n`git branch -m oldname newname` 重命名本地分支：\n\n### <font color=#00BFF> 16 Git checkout</font>\n\n`git checkout branch-name` \\# 切换到 branch-name\n`git checkout master` \\# 切换到 master\n`git checkout -b new-branch master` \\# 从 master 建立新的 new-branch, 并同时切换过去 new-branch\n`git checkout -b newbranch` \\# 由现在的环境为基础, 建立新的 branch\n`git checkout -b newbranch origin` \\# 于 origin 的基础, 建立新的 branch\n`git checkout filename` \\# 还原档桉到 Repository 状态\n`git checkout HEAD .` \\# 将所有档桉都 checkout 出来(最后一次 commit 的版本), 注意, 若有修改的档桉都会被还原到上一版. (git checkout -f 亦可)\n`git checkout xxxx .` \\# 将所有档桉都 checkout 出来(xxxx commit 的版本, xxxx 是 commit 的编号前四码), 注意, 若有修改的档桉都会被还原到上一版.\n`git checkout -` 切回上一个分支\n<code>git checkout -- [file]</code> 撤销对文件的修改\n\n###<font color=#00BFF>17 Git blame</font>=\n`git blame filename` \\# 关于此档桉的所有 commit 纪录\n\n###<font color=#00BFF>18 Git stash </font>\n`git stash` \\# 丢进暂存区\n`git stash list `\\# 列出所有暂存区的资料\n`git stash pop `\\# 取出最新的一笔, 并移除.\n`git stash apply` \\# 取出最新的一笔 stash 暂存资料. 但是 stash 资料不移除\n`git stash clear `\\# 把 stash 都清掉\n\n\n###<font color=#00BFF>19 Git merge </font>\n<code> git merge\ngit merge master\ngit merge new-branch</code>\n`git merge --no-ff feature-A`  在历史记录中明确记录下本次分支合并\n\n\n`git status -s` \n\n---"
    },
    {
      "type": "markdown",
      "data": "# <font color=#8DEEEE face=\"黑体\">git 拉取代码</font>\n\n设置代码库SSH \n--SSH Keys\n\nSSH key allows you to establish a secure connection between your computer and GitLab\n\nTo generate a new SSH key just open your terminal and use code below.\n\n<code>ssh-keygen -t rsa -C \"liu@qq.com\"</code>\nCreates a new ssh key using the provided email\nGenerating public/private rsa key pair...\n\nNext just use code below to dump your public key and add to GitLab SSH Keys\n<code>cat ~/.ssh/id_rsa.pub</code>\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....\n把公钥添加到code平台中\n\n---\n### <font color=#9AFF9A face=\"黑体\">Workflow</font>\n\nClone project\n\n1 <code>git clone git@example.com:project-name.git</code>\nCreate branch with your feature\n\n2 <code>git checkout -b [feature_name]</code>\nWrite code. Commit changes\n\n3 <code>git commit -am \"My feature is ready\"</code>\nPush your branch to GitLab\n\n4 <code>git push origin [feature_name]</code>\n\n5 Review your code on Commits page\n\n6 Create a merge request\n\n7 Your team lead will review code & merge it to main branch"
    },
    {
      "type": "markdown",
      "data": "---------------------------\nvi ~/.gitconfig \n\nssh-keygen -t rsa -C \"liuzy@qq.com \" -f ~/.ssh/meituan-rsa\n\ngit config --global user.name \"username\"\ngit config --global user.email \"email\"\n\nssh-add -D\n\n### github.com\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\n\n### www.oschina.net\nHost www.oschina.net\nHostName www.oschina.net\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\n"
    },
    {
      "type": "markdown",
      "data": "### <font color=#9AFF9A face=\"黑体\">Git 内部原理</font>\nGit 是一个内容寻址文件系统，这意味着Git 的核心部分是一个简单的键值 对数据库。可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值 可以在任意时刻再次检索该内容。\n\n` gc ` 来查看数据库占用了多少空间\n`git count-objects -v`  查看占用空间大小\n"
    }
  ]
}