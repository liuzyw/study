{
  "title": "数据库事务4种隔离级别及7种传播行为",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\">一、隔离级别：</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">数据库事务的隔离级别有4个，由低到高依次为<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">Read uncommitted、<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">Read committed、<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">Repeatable read、<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">Serializable，这四个级别可以逐个解决<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">脏读、<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">不可重复读、<span class=\"importance\" style=\"margin: 0px; padding: 0px;\">幻读这几类问题。</span></span></span></span></span></span></span></span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><span class=\"importance\" style=\"margin: 0px; padding: 0px;\"><img src=\"quiver-image-url/8B0366B934AFFFC10FE5E694A45C7695.png\" alt=\"\" style=\"margin: 0px; padding: 0px; border: 0px; max-width: 900px;\" width=\"642\" height=\"238\"></span></span></span></span></span></span></span></span></p><p class=\"p\" style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">１.<span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">&nbsp;ISOLATION_READ_UNCOMMITTED：</span>这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这种隔离级别会产生脏读，不可重复读和幻像读。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">２.&nbsp;<span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">ISOLATION_READ_COMMITTED：</span>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">３.&nbsp;<span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">ISOLATION_REPEATABLE_READ：</span>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">４.&nbsp;<span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">ISOLATION_SERIALIZABLE：</span>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除了防止脏读，不可重复读外，还避免了幻像读。&nbsp;</span></p><hr style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\">我们使用 test 数据库，新建 tx 表：－－－ＭｙＳＱＬ数据库</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\"><strong style=\"margin: 0px; padding: 0px;\">第1级别：Read Uncommitted(读取未提交内容)</strong></span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(1)所有事务都可以看到其他未提交事务的执行结果</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(3)该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</span></p><div class=\"cnblogs_code\" style=\"margin: 5px 0px; padding: 5px; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); overflow: auto; color: rgb(0, 0, 0); font-variant-ligatures: normal; orphans: 2; widows: 2; font-family: 'Courier New' !important; font-size: 12px !important;\"><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New' !important;\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">#首先，修改隔离级别\nset tx_isolation</span>='READ-UNCOMMITTED'<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect @@tx_isolation;\n</span>+------------------+\n| @@tx_isolation   |\n+------------------+\n| READ-UNCOMMITTED |\n+------------------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：启动一个事务\nstart transaction;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务B：也启动一个事务(那么两个事务交叉了)\n       在事务B中执行更新语句，且不提交\nstart transaction;\nupdate tx set num</span>=10 where id=1<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：那么这时候事务A能看到这个更新了的数据吗</span>?<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |   ---&gt;<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">可以看到！说明我们读到了事务B还没有提交的数据\n</span>|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务B：事务B回滚,仍然未提交\nrollback;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：在事务A里面看到的也是B没有提交的数据\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |      ---&gt;<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！\n</span>|    2 |    2 |\n|    3 |    3 |\n+------+------+</pre><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div></div><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\"><strong style=\"margin: 0px; padding: 0px;\">第2级别：Read Committed(读取提交内容)</strong></span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">&nbsp;&nbsp;&nbsp;&nbsp; |——&gt;<span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">导致这种情况的原因可能有：</span>(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</span></p><div class=\"cnblogs_code\" style=\"margin: 5px 0px; padding: 5px; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); overflow: auto; color: rgb(0, 0, 0); font-variant-ligatures: normal; orphans: 2; widows: 2; font-family: 'Courier New' !important; font-size: 12px !important;\"><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New' !important;\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">#首先修改隔离级别\nset tx_isolation</span>='read-committed'<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect @@tx_isolation;\n</span>+----------------+\n| @@tx_isolation |\n+----------------+\n| READ-COMMITTED |\n+----------------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：启动一个事务\nstart transaction;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务B：也启动一个事务(那么两个事务交叉了)\n       在这事务中更新数据，且未提交\nstart transaction;\nupdate tx set num</span>=10 where id=1<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：这个时候我们在事务A中能看到数据的变化吗</span>?<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\nselect </span>* from tx; ---------------&gt;\n+------+------+                |\n| id   | num  |                |\n+------+------+                |\n|    1 |    1 |---&gt;并不能看到！  |\n|    2 |    2 |                |\n|    3 |    3 |                |\n+------+------+                |——&gt;<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">相同的select语句，结果却不一样\n                                  </span>|<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n#事务B：如果提交了事务B呢</span>?            |<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\ncommit;                           </span>|\n                                  |<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n#事务A:                            </span>|<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\nselect </span>* from tx; ---------------&gt;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |---&gt;<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">因为事务B已经提交了，所以在A中我们看到了数据变化\n</span>|    2 |    2 |\n|    3 |    3 |\n+------+------+</pre><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div></div><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\"><strong style=\"margin: 0px; padding: 0px;\">第3级别：Repeatable Read(可重读)</strong></span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(1)这是MySQL的默认事务隔离级别</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</span></p><div class=\"cnblogs_code\" style=\"margin: 5px 0px; padding: 5px; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); overflow: auto; color: rgb(0, 0, 0); font-variant-ligatures: normal; orphans: 2; widows: 2; font-family: 'Courier New' !important; font-size: 12px !important;\"><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New' !important;\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">#首先，更改隔离级别\nset tx_isolation</span>='repeatable-read'<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect @@tx_isolation;\n</span>+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：启动一个事务\nstart transaction;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务B：开启一个新事务(那么这两个事务交叉了)\n       在事务B中更新数据，并提交\nstart transaction;\nupdate tx set num</span>=10 where id=1<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\ncommit;\n\n#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 | ---&gt;<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)\n</span>|    2 |    2 |\n|    3 |    3 |\n+------+------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：只有当事务A也提交了，它才能够看到数据变化\ncommit;\nselect </span>*<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> from tx;\n</span>+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+</pre><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div></div><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\"><strong style=\"margin: 0px; padding: 0px;\">第4级别：Serializable(可串行化)</strong></span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(1)这是最高的隔离级别</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。</span><br style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\">(3)在这个级别，可能导致大量的超时现象和锁竞争</span></p><div class=\"cnblogs_code\" style=\"margin: 5px 0px; padding: 5px; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); overflow: auto; color: rgb(0, 0, 0); font-variant-ligatures: normal; orphans: 2; widows: 2; font-family: 'Courier New' !important; font-size: 12px !important;\"><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New' !important;\"><span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">#首先修改隔离界别\nset tx_isolation</span>='serializable'<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nselect @@tx_isolation;\n</span>+----------------+\n| @@tx_isolation |\n+----------------+\n| SERIALIZABLE   |\n+----------------+<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">\n\n#事务A：开启一个新事务\nstart transaction;\n\n#事务B：在A没有commit之前，这个交叉事务是不能更改数据的\nstart transaction;\ninsert tx values(</span>'4','4'<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">);\nERROR </span>1205 (HY000): Lock wait timeout exceeded; <span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 255); line-height: 1.5 !important;\">try</span><span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\"> restarting transaction\nupdate tx set num</span>=10 where id=1<span style=\"margin: 0px; padding: 0px; line-height: 1.5 !important;\">;\nERROR </span>1205 (HY000): Lock wait timeout exceeded; <span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 255); line-height: 1.5 !important;\">try</span> restarting transaction</pre><div class=\"cnblogs_code_toolbar\" style=\"margin: 5px 0px 0px; padding: 0px;\"><span class=\"cnblogs_code_copy\" style=\"margin: 0px; padding: 0px 5px 0px 0px; line-height: 1.5 !important;\"><a title=\"复制代码\" style=\"margin: 0px; padding: 0px; text-decoration: underline; border: none !important;\"><img src=\"quiver-image-url/51E409B11AA51C150090697429A953ED.gif\" alt=\"复制代码\" style=\"margin: 0px; padding: 0px; max-width: 900px; border: none !important;\" width=\"20\" height=\"20\"></a></span></div></div><hr style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px; color: rgb(0, 0, 128);\">二、传播行为</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">1、PROPAGATION_REQUIRED</span>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">2、PROPAGATION_SUPPORTS</span>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">3、PROPAGATION_MANDATORY：</span>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">4、PROPAGATION_REQUIRES_NEW</span>：创建新事务，无论当前存不存在事务，都创建新事务。</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">5、PROPAGATION_NOT_SUPPORTED：</span>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">6、PROPAGATION_NEVER：</span>以非事务方式执行，如果当前存在事务，则抛出异常。</span></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\">&nbsp;</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><span style=\"margin: 0px; padding: 0px; color: rgb(0, 0, 128);\">7、PROPAGATION_NESTED：</span>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</span></p><div><span style=\"margin: 0px; padding: 0px; font-size: 18px;\"><br></span></div>"
    }
  ]
}